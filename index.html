<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>uji</title>
    <link rel="stylesheet" href="iosevka-aile/3.4.6/iosevka-aile.css">
    <style>
        @font-face {
            font-family: 'NotoSansImperialAramaic';
            font-weight: 400;
            font-style: normal;
            src: url('NotoSansImperialAramaic-unhinted/NotoSansImperialAramaic-Regular.ttf') format('truetype');
        }
        @font-face {
            font-family: 'NotoSansTifinagh';
            font-weight: 400;
            font-style: normal;
            src: url('NotoSansTifinagh-unhinted/NotoSansTifinagh-Regular.ttf') format('truetype');
        }

        :root {
            --sidebar-width: 22em;
        }

        * {
            margin: 0;
            box-sizing: border-box;
        }
        html {
            /*filter: invert(1)*/;
            font-size: 12px;
        }
        body {
            font-family: "Iosevka Aile Web", sans-serif;
            line-height: 1.2;
            background-color: #111;
            color: #eee;
        }
        .sidebar {
            width: var(--sidebar-width);
            min-height: 100vh;
            background-color: #333;
            padding: 1em;
            padding-bottom: 7em;
        }
        .logo {
            float: left;
            width: 52px;
            margin-right: 1em;
        }
        .logo path:hover {
            stroke-width: 2px;
            stroke: yellow;
        }
        p.hero {
            margin-top: -0.2em;
        }
        a {
            color: inherit;
            opacity: 0.66;
        }
        hr, label {
            margin: 1em 0;
        }
        hr {
            border: none;
            height: 1px;
            background-color: #555;
        }
        .presets + hr {
            margin-top: 0.5em;
        }
        label {
            display: block;
        }
        .letter {
            font-family: NotoSansImperialAramaic;
            display: inline-block;
            width: 2rem;
            height: 2rem;
            text-align: center;
            background-color: #aaa;
            color: black;
            font-size: 1.8em;
            line-height: 1;
            vertical-align: top;
        }
        .value {
            display: inline-block;
            position: absolute;
            width: 3em;
            pointer-events: none;
            text-align: right;
            margin-left: -3em;
            padding: 0.1em 0.2em;
        }
        .description {
            font-size: 0.85em;
        }
        input[type="range"] {
            vertical-align: top;
            display: inline-block;
            -webkit-appearance: none;
            width: calc(100% - 2rem);
            height: 2rem;
            background-color: #666;
            outline: none;
            border: 0;
        }
        label:hover input[type="range"],
        input[type="range"]:active {
            background-color: #888;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1rem;
            height: 2rem;
            background: #fff;
        }
        input[type="range"]::-moz-range-thumb {
            width: 1em;
            height: 2em;
            background: #fff;
            border: 0;
            border-radius: 0;
        }
        input[type="range"].red::-webkit-slider-thumb {
            background: red;
        }
        .buttons {
            position: fixed;
            z-index: 1000;
            width: var(--sidebar-width);
            left: 0;
            bottom: 0;
            background: linear-gradient(to bottom, transparent, #0004 1em, #555 1em, #555 100%);
            padding: 2em 1em 0.5em;
        }
        button {
            background-color: #ddd;
            font: inherit;
            color: black;
            border: 0;
            font-size: 1em;
            padding: 0.35em 0.5em 0.45em 0.5em;
            margin-bottom: 0.5em;
            cursor: pointer;
            text-transform: uppercase;
        }
        button:hover {
            background-color: #aaa;
        }
        .presets button {
            font-family: NotoSansTifinagh;
            font-size: 1.3em;
            width: 2em;
            padding: 0.2em;
        }
        .drawing {
            position: fixed;
            top: 0;
            right: 0;
            height: 100vh;
            width: calc(100% - var(--sidebar-width));
            display: grid;
        }
        .drawing canvas {
            margin: auto;
            max-height: 100vh !important;
            background-color: white;
        }
    </style>
</head>
<body>
    <aside class="buttons">
        <button name="reset">reset</button>
        <button name="playpause">pause</button>
        <button name="download">download</button>
        <button name="share">share</button>
        <button name="randomize">randomize</button>
    </aside>
    <aside class="sidebar">
        <svg class="logo" xmlns="http://www.w3.org/2000/svg" version="1.1" style="stroke-linecap: round; stroke-width: 4px; stroke: #eee; fill: none;" viewBox="0 0 52 52">
            <g transform="translate(2,2)">
                <path d="M 0,0 L 0,16"></path>
                <path d="M 32,0 L 32,16"></path>
                <path d="M 40,0 L 40,32"></path>
                <path d="M 48,0 L 48,48"></path>
                <path d="M 0,48 L 24,48"></path>
                <path d="M 16,32 C -0.8,32 0,16 0,16"></path>
                <path d="M 16,32 C 32.8,32 32,16 32,16"></path>
                <path d="M 24,48 C 40.8,48 40,32 40,32"></path>
            </g>
        </svg>
        <p class="hero">A minimalist generative art thing ‚Äì play with the sliders and press the buttons. Find out <a href="https://github.com/doersino/uji">more on GitHub.</a></p>
        <hr>
        <div class="presets">
            <button name="preset1">‚¥≤</button>
            <button name="preset2">‚µÖ</button>
            <button name="preset3">‚µì</button>
            <button name="preset4">‚µç</button>
        </div>
        <div class="bitsnbobs">
            <label><div class="letter">ê°Ä</div><input type="range" min="1" max="100" value="50"><div class="value">50</div><div class="description">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod.</div></label>
            <label><div class="letter">ê°î</div><input type="range" min="1" max="100" value="50" class="red"><div class="value">100</div></label>
            <label><div class="letter">ê°ã</div><input type="range" min="1" max="100" value="50"><div class="value">0.25</div></label>
            <hr>
        </div>
        <!--
        https://en.m.wikipedia.org/wiki/Imperial_Aramaic_(Unicode_block)
        https://en.m.wikipedia.org/wiki/Buhid_(Unicode_block)
        https://en.m.wikipedia.org/wiki/Tifinagh_(Unicode_block)

        TODO
        * make options actually affect the drawing
        * make presets work (once selected, hover state persists until another selected to sliders changed)
        * make buttons work
        * add colors etc.
        * maybe add square mode, or some other things that require multi-selects instead of buttons
        * make work on mobile (square at top, scrollable list on bottom)
        -->
    </aside>
    <script>
        a
        const options = {
            radius: {letter: "ê°Ä", min: 0, max: 3000, step: 10},
            segments: {letter: "ê°Ä", min: 100, max: 10000, step: 100},
        };
        const defaults = {
            radius: 100,
            segments: 1000
        };
        let optionValues = JSON.parse(JSON.stringify(defaults));

        function setupOptions() {
            let rendered = "";
            Object.keys(options).forEach(n => {
                const o = options[n];
                const v = optionValues[n];
                rendered += `<label><div class="letter">${o.letter}</div><input type="range" min="${o.min}" max="${o.max}" step="${o.step}" value="${v}" name="${n}" oninput="handleOptionInput(this)" id="option-${n}"><div class="value">${v}</div></label>`;
            })
            document.querySelector(".bitsnbobs").innerHTML = rendered;
        }
        setupOptions();

        function handleOptionInput(e) {
            optionValues[e.name] = e.value;
            e.parentElement.querySelector(".value").innerText = e.value;
            restartRendering();
        }
        function refreshRenderedOption(name) {
            const e = document.querySelector(`.bitsnbobs [name=${name}]`);
            const v = optionValues[name];
            e.value = v;
            e.parentElement.querySelector(".value").innerText = v;
        }
        function refreshAllRenderedOptions() {
            Object.keys(options).forEach(refreshRenderedOption);
        }
        function applyPreset(preset) {
            optionValues = Object.assign(optionValues, preset);
            refreshAllRenderedOptions();
            restartRendering();
        }

        function restartRendering() {
            // clear interval, reset, apply options, restart
        }
    </script>
    <div class="drawing">
        <canvas></canvas>
    </div>
    <script>
        let dimensions = [2000, 2000];

        ////////////////////////////////////////////////////////////////////////

        let canvas = document.getElementsByTagName("canvas")[0];

        let w, h, dpr, W, H;

        if (dimensions) {
            w = W = dimensions[0];
            h = H = dimensions[1];
            canvas.style.maxHeight = "100%";
            canvas.style.maxWidth = "100%";
            canvas.setAttribute("width", W);
            canvas.setAttribute("height", H);
        } else {
            // set height and width correctly on retina devices
            // w, h: logical pixels
            // W, H: physical pixels
            w = window.innerWidth;
            h = window.innerHeight;
            dpr = 1;
            if (window.devicePixelRatio) {
                dpr = window.devicePixelRatio;
                canvas.style.width = w + "px";
                canvas.style.height = h + "px";
                W = w * dpr;
                H = h * dpr;
            }
            canvas.setAttribute("width", W);
            canvas.setAttribute("height", H);
        }

        // based on https://stackoverflow.com/a/16245768
        function htmlToObjectURL(html) {
            const sliceSize = 512;
            const byteArrays = [];

            for (let offset = 0; offset < html.length; offset += sliceSize) {
                const slice = html.slice(offset, offset + sliceSize);

                const byteNumbers = new Array(slice.length);
                for (let i = 0; i < slice.length; i++) {
                    byteNumbers[i] = slice.charCodeAt(i);
                }

                const byteArray = new Uint8Array(byteNumbers);
                byteArrays.push(byteArray);
            }

            const blob = new Blob(byteArrays, {type: 'text/html'});
            const url = URL.createObjectURL(blob)
            return url;
        }

        function canvasToDataURL(canvas) {
            return canvas.toDataURL();
        }

        function downloadFile(hrefData, filename) {
            let a = document.createElement("a");
            a.href = hrefData;
            a.setAttribute("download", filename);
            document.body.appendChild(a);
            a.click();
            a.outerHTML = "";
        }

        function download() {
            let filename = "art_" + new Date().toISOString().replace(/\:/g, ".");
            downloadFile(htmlToObjectURL(document.documentElement.outerHTML), filename + ".html")
            setTimeout(() => {downloadFile(canvasToDataURL(canvas), filename + ".png");}, 100);  // safari doesn't like two simultaneous downloads
        }

        function refresh() {
            location.reload(true)
        }

        function stop() {
            clearInterval(inter);
        }

        // out-of-place rotation of p = [x‚ÇÅ,y‚ÇÅ] around o = [x‚ÇÇ,y‚ÇÇ], based on
        // http://stackoverflow.com/a/2259502
        function rotate(o, p, angle) {
            var s = Math.sin(angle);
            var c = Math.cos(angle);

            // copy point
            p = [p[0],p[1]];

            // translate point back to origin
            p[0] -= o[0];
            p[1] -= o[1];

            // rotate point
            var xnew = p[0] * c - p[1] * s;
            var ynew = p[0] * s + p[1] * c;

            // translate point back:
            p[0] = xnew + o[0];
            p[1] = ynew + o[1];

            return p;
        }

        let ctx = canvas.getContext("2d");

        let r = Math.random;

        // generate initial line
        let center = [W / 2, 0];
        let radius = 1000;
        let segments = 10000;
        let line1 = [];
        for (let i = 0; i < segments/2; i++) {
            /*let x = center[0] + 2 * radius * Math.cos((i / segments) * 2 * Math.PI);
            let y = center[1] + 2 * radius * Math.sin((i / segments) * 2 * Math.PI);*/

            /*let x, y;
            if (i < segments / 4) {
                x = center[0] - radius + 2 * radius * (i / (segments / 4));
                y = center[1] - radius;
            } else if (i < segments / 2) {
                x = center[0] + radius;
                y = center[1] - radius + 2 * radius * ((i - segments / 4) / (segments / 4));
            } else if (i < 3 * segments / 4) {
                x = center[0] + radius - 2 * radius * ((i - segments / 2) / (segments / 4));
                y = center[1] + radius;
            } else {
                x = center[0] - radius;
                y = center[1] + radius - 2 * radius * ((i - 3 * segments / 4) / (segments / 4));
            }*/

            let x = center[0] - radius + 2 * radius * (i / segments * 2);
            let y = center[1];

            line1.push([x,y]);
        }
        let line2 = [];
        for (let i = 0; i < segments/2; i++) {
            let x = center[0] - radius + 2 * radius * (i / segments * 2);
            let y = center[1] + H/3;

            line2.push([x,y]);
        }
        let lines = [line1, line2];

        // thing goes brr
        let n = 0;
        let inter = setInterval(() => {
            if (n++ > 5000) return;

            ctx.beginPath();

            // draw
            lines = lines.map((l, li) => {
                l = l.map((p, i) => {

                    let x = p[0];
                    let y = p[1];

                    if (i == 0 || r() > 0.4) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x = center[0] + (x - center[0] + r() - 0.5) * 1.001 + 0.5 * li;
                    y = center[1] + (y - center[1] + r() - 0.5) + 3;

                    return rotate(center, [x,y], 0.001 * (li + 1));
                });

                ctx.strokeStyle = "rgba(0,0,0,0.03)";
                ctx.stroke();

                return l;
            });
        }, 1000/60);
    </script>
</body>
